-module(bigset_client).
-include("bigset.hrl").
-include_lib("riak_core/include/riak_core_vnode.hrl").

-export([
         ping/0,
         update/2,
         read/2,
         stream_read/2,
         update/4
        ]).

-define(DEFAULT_TIMEOUT, 60000).

%% an opaque binary riak_dt_vclock:vclock()
-type context() :: binary() | undefined.
-type remove() :: {member(), context()}.


%% Public API

%% @doc Pings a random vnode to make sure communication is functional
ping() ->
    DocIdx = riak_core_util:chash_key({<<"ping">>, term_to_binary(now())}),
    PrefList = riak_core_apl:get_primary_apl(DocIdx, 1, bigset),
    [{IndexNode, _Type}] = PrefList,
    riak_core_vnode_master:sync_spawn_command(IndexNode, ping, bigset_vnode_master).

-spec update(set(), Adds :: [member()]) ->
                    ok | {error, Reason :: term()}.
update(Set, Adds) ->
    update(Set, Adds, [], []).

%% @doc update a Set
-spec update(set(),
             Adds :: [member()],
             Removes :: [remove()],
             Options :: proplists:proplist()) ->
                    ok | {error, Reason :: term()}.
update(Set, Adds, Removes, Options) ->
    Me = self(),
    ReqId = mk_reqid(),
    %% if there are removes, there must a Ctx
    Ctx = validate_ctx(Removes, proplist:get_value(ctx, Options)),
    Op = ?OP{set=Set, inserts=Adds, removes=Removes, ctx=Ctx},
    bigset_write_fsm:start_link(ReqId, Me, Set, Op, Options),
    Timeout = recv_timeout(Options),
    wait_for_reqid(ReqId, Timeout).

%% @private right now removes _MUST_ have a binary-context. Throw if
%% they do not!
validate_ctx([], Ctx) ->
    Ctx;
validate_ctx(_Removes, Ctx) when not is_binary(Ctx) ->
    throw({error, removes_require_ctx});
validate_ctx(_Removes, Ctx) ->
    Ctx.

read(Set, Options) ->
    Me = self(),
    ReqId = mk_reqid(),
    bigset_read_fsm:start_link(ReqId, Me, Set, Options),
    Timeout = recv_timeout(Options),
    wait_for_read(ReqId, Timeout).

stream_read(Set, Options) ->
     Me = self(),
    ReqId = mk_reqid(),
    {ok, Pid} = bigset_read_fsm:start_link(ReqId, Me, Set, Options),
    {ok, ReqId, Pid}.


recv_timeout(Options) ->
    case proplists:get_value(recv_timeout, Options) of
        undefined ->
            %% If no reply timeout given, use the FSM timeout + 100ms to give it a chance
            %% to respond.
            proplists:get_value(timeout, Options, ?DEFAULT_TIMEOUT) + 100;
        Timeout ->
            %% Otherwise use the directly supplied timeout.
            Timeout
    end.

wait_for_reqid(ReqId, Timeout) ->
    receive
        {ReqId, {error, overload}=Response} ->
            case app_helper:get_env(riak_kv, overload_backoff, undefined) of
                Msecs when is_number(Msecs) ->
                    timer:sleep(Msecs);
                undefined ->
                    ok
            end,
            Response;
        {ReqId, Response} -> Response
    after Timeout ->
            {error, timeout}
    end.

-record(read_acc, {ctx,elements}).

%% How to stream??  Ideally the process calling the client calls
%% receive!
wait_for_read(ReqId, Timeout) ->
    wait_for_read(ReqId, Timeout, #read_acc{}).
%% @private
wait_for_read(ReqId, Timeout, Acc) ->
    receive
        {ReqId, done} ->
            #read_acc{ctx=Ctx, elements=Elems} = Acc,
            {ok, {ctx, Ctx}, {elems, lists:flatten(Elems)}};
        {ReqId, {ok, {ctx, Ctx}}} ->
                wait_for_read(ReqId, Timeout, Acc#read_acc{ctx=Ctx});
        {ReqId, {ok, {elems, Res}}} ->
            #read_acc{elements=Elems} = Acc,
            wait_for_read(ReqId, Timeout, Acc#read_acc{elements=[Res|Elems]});
        {ReqId, {error, Error}} ->
            {error, Error}
    after Timeout ->
            {error, timeout}
    end.

%% @private
mk_reqid() ->
    erlang:phash2({self(), os:timestamp()}). % only has to be unique per-pid
